# predict_run
## 一、数据接口
从Subscriber中读取识别结果
数据格式为结构体DETECT_MSG
里面包含：探测到的装甲板的信息res，陀螺仪信息imu_data，原图像src，时间戳time_stamp
装甲板信息结构体包含：装甲板的四点在图像上的坐标pts[5]（由于detect采用了五点模型，需要舍弃最后一个点），置信度conf，装甲板颜色color与装甲板类型type
color：0表示蓝色，1表示红色，2表示白色，3表示紫色。
type：0表示哨兵，1表示英雄，2表示工程，3、4、5表示步兵，6表示无人机，7表示前哨站，8表示基地

进行运算

将计算结果通过Publisher发布给电控
发布数据格式为结构体CONTROL_CMD
里面包含（roll），yaw，pitch三（两）个角度，表示需要将枪口转至的角度位置
与一个时间wait，表示若在此时选择发射，则需要延迟wait秒再发射才能打中敌方装甲板（用于反陀螺）

## 二、一些基础知识
### 1、相机系、云台系、base系
预测与弹道计算最终在base系下进行
PNP解算时定义世界坐标系原点为装甲板中心点，那么解算结果中的平移矩阵就是装甲板中心点在相机系下的坐标。
相机系到云台系的旋转矩阵和平移矩阵需要通过相机标定计算得出
云台系到base系的旋转矩阵可通过陀螺仪得出（注意矩乘的顺序）
由于base系的原点与发射装置的坐标有一定差距，所以还需要通过调参计算出偏差的旋转矩阵和平移矩阵
### 2、扩展卡尔曼滤波
https://blog.csdn.net/C20180602_csq/article/details/122487591
### 3、相机内参标定与相机云台标定
详见屈扬学长的文档
### 4、xyz轴的朝向问题，roll/yaw/pitch正负方向问题
相机系默认x朝右、y朝下、z朝前
相机系到云台系的旋转矩阵与相机标定的内容有很大关系，特别注意陀螺仪的安装方向带来的问题
base系x、y、z朝向与roll/yaw/pitch正负方向建议在所有代码开始写之前就与电控协商好！！！
### 5、左右手系快速判定
使用向量叉乘方向的判定方法，x轴叉乘y轴的结果方向与z轴同向，则为右手系，否则为左手系

## 三、主体部分运行过程
### Part 1&2、初始化并计算所有装甲板的中心点在base系下的坐标
此部分实现较为容易

###Part 2.5、编号过滤
考虑到
此部分是应对编号误识别而提出的算法，该算法主要分为两部分，一部分是基于贪心的帧间匹配，另一部分是基于摩尔投票算法的编号修正。
该算法本质上是利用识别信息在空间上较强的连续性，来过滤编号识别中的闪烁情况。
数据结构armo包含：
装甲板中心的base系坐标：p
装甲板被探测到的时间戳：TS
装甲板的编号：id
装甲板编号的权重：cnt
数据结构armo_filter包含：
armo数组（保存的是过去的处理结果，或是现在的识别结果）
armo数组大小：cnt
1、帧间匹配：
在帧间匹配之前，首先需要剔除掉过去装甲板信息中时间戳与当前时间戳差距过大的信息

然后对任意一个当前装甲板，都需要枚举过去处理好的装甲板，判断二者的中心点距离是否再预设范围内以及突变幅度是否在某范围内，如果符合条件，则在二者之间连一条边，边长为二者中心点距离。
将所有的边按照边长从小到大排序，顺次枚举每一条边，如果边上两点均未匹配，则将他们匹配。
这样的贪心匹配其实是不优秀的，比如如下情况（A本应对应A’，B本应对应B’）

上述贪心算法会将B与A’相匹配
但是由于帧数较高（达到了每秒100帧），实际情况中AA’与BB’的长度都很短
即便是出现这种误匹配情况也会在下文中有处理的方案。

注意在编号过滤时，编号信息不能帧间匹配作为判据
（但是事实上编号信息可以在帧间匹配中占有一定的决策权重，这是未来的优化方向之一）
2、编号修正
通过帧间匹配我们可以得到空间中的多条路径
利用摩尔投票算法统计每条路径中出现次数超过一半的编号的数目，并将此编号作为编号过滤的结果。
关于误匹配，我们可以设置摩尔投票法中的权重最大值Inertia。
这样的话，如果连续出现Inertia帧误识别（在此之前未出现误识别），最终的编号过滤结果才会改变。如果出现误匹配，在经过Inertia帧之后也会修正编号。
3、Part2.5与Part3的衔接部分
由于误识别的存在，可能会出现某一编号的装甲板多次出现的情况，我们只需找到同一编号中距离最近的两块装甲板（最可能是同一机器人上的两块装甲板）作为处理结果传输给Part3即可。

### Part 3、更新滤波器
一些细节：
1、同一个机器人的装甲板在视野中最多出现两块，可以用机器人ID为下标来储存每个机器人的探测信息
ID=color*9+type
储存机器人探测信息的结构体node包含：
装甲板中心的base系坐标：p，p2
装甲板被探测到的时间戳：TS，TS2
装甲板数量：armor_cnt
装甲板对应的滤波器的编号：ekf_id，ekf_id2
2、利用向量叉积来判断同一机器人两块装甲板的左右位置

初始化时提前给每个机器人的两个装甲板分配滤波器地址

先将上一时刻与当前时刻的时间戳之差在某范围外的装甲板进行剔除
剔除这些装甲板之后，则剩下的就是有效装甲板
关键问题在于，如何判断当前时刻的装甲板对应的上一时刻的装甲板
由于我们是以机器人ID为下标来进行储存的，所以不同ID的机器人的装甲板不会互相干扰
于是我们只需要考虑一个机器人的装甲板的对应关系
对某机器人进行分类讨论
1、若上一时刻装甲板数为1，当前时刻装甲板数为1
则更新对应的滤波器，时间戳以及中心点坐标
2、若上一时刻装甲板数为2，当前时刻装甲板数为2
则利用向量叉积来判断装甲板在视野中的左右位置关系，对应更新即可
3、若上一时刻装甲板数为1，当前时刻装甲板数为2
则让距离上一时刻装甲板最近的当前时刻装甲板继承滤波器并更新
注意，虽然上一时刻的装甲板数为1，但是有可能第二块装甲板是有效的，所以还要判断是否需要更新第二块装甲板
4、若上一时刻装甲板数为2，当前时刻装甲板数为1
则让继承距离当前时刻装甲板最近的上一时刻装甲板的滤波器并更新
将此时的时间戳与装甲板中心点坐标保存下来（用于后续反陀螺的周期解算）

最后，需要将更新后的某机器人对应的装甲板数目赋为max(上一时刻装甲板数，当前时刻装甲板数)，以便于下一时刻有效装甲板的筛选。

### Part 3.5、在图上标注预测点
将base系点的坐标转到相机系再进行投影变换
建议自己先推一下式子

### Part 4、自瞄优先级
此段逻辑较复杂
哨兵：英雄>上一次跟踪的目标>高地最近步兵>低地最近步兵>远处英雄（应该可以加入工程）
步兵：上一次跟踪的目标>离图像中心点最近的目标
注意自瞄有最大距离范围限制

### Part 4.5、反陀螺判定与周期解算
对于每一个机器人都开一个循环队列，储存装甲板数目2->1时刻的时间戳与装甲板中心点坐标
在Part 3部分中把装甲板数目2->1的时间戳存入循环队列中，同时注意短时间闪烁的情况，加一个最低时间限制防止抖动。
反陀螺判定条件：在某个时间范围内2->1变换次数大于了阈值，则判定为陀螺模式。也可以手动开启。
注意在判定前需要弹出在该时间范围外的时间戳
考虑到可能有变速陀螺的情况，所以取临近的若干个时间戳来计算周期（其实有用的是 周期/4）
考虑到在击打陀螺时，己方或敌方会进行移动，所以需要新建一个滤波器，将循环队列中的装甲板坐标依次放入滤波器进行预测
具体结果的求解见下文

### Part 5&6&7、计算发射角度与延迟时间
经过前面的操作，我们已经得知了需要跟踪的目标和与其对应的滤波器
1、正常自瞄模式
首先使用滤波器预测目标在0秒之后的坐标，使用该坐标计算子弹的飞行时间t1
然后使用滤波器预测目标在t1秒之后的坐标，使用该坐标计算子弹的飞行时间t2
……
其实只需要迭代两三次即可，最后一次计算的时候保留一下角度yaw，pitch
wait等于0
2、反陀螺自瞄模式
通过解算的周期，由近到远枚举下一次打中的时间点
最后一次记录的2->1的时间戳 + 周期/4*枚举值i = 当前时间戳 + 子弹打中 经过周期/4*枚举值i时间的目标的预测位置 的飞行时间 + 电控延迟时间（几乎没有） + wait
移项后即可计算wait值，当wait值大于0时即是合法解


# EKF
## 学习资料与运行过程
https://blog.csdn.net/C20180602_csq/article/details/122487591
拓展资料：《无迹卡尔曼滤波在目标跟踪中的应用.pdf》
## 数据接口
EKF是一个类
包含三个函数和若干个矩阵
void reset(Eigen::Matrix<double,3,1> tmp)
用于重置滤波器，将滤波器初始状态设置为在tmp坐标，x、y、z速度均为0
Vy predict(double dT)
用于预测，使用滤波后的状态，计算dT秒后的坐标
void update(const Vy &Y,const double dT)
用于更新滤波器，观测状态为Y、与上一次时间间隔为dT，以此来更新滤波后的状态

# ballistic
## 学习资料
高中物理教材
拓展：可以自己尝试推导带空气阻力的运动轨迹方程，需要运用微分方程的知识
（我记得有一个pdf，但是忘记放哪儿了。。。。）
## 运行过程
计算目标点与原点的水平距离记为x，垂直距离记为y
则有方程：
$$v_xt=x$$
$$v_yt=y+\frac{1}{2}gt^2$$
由于
$$v_x^2+v_y^2=v^2$$
所以把前面两式同时平方并相加，得：
$$v_x^2t^2=x^2$$
$$v_y^2t^2=y^2+ygt^2+\frac{1}{4}g^2t^4$$
$$v^2t^2=x^2+y^2+ygt^2+\frac{1}{4}g^2t^4$$
解二次方程即可得到t
注意判定无解的情况，多解时取**较小**的解
前两式作比后求反正切可得pitch角度
$$pitch=arctan(\frac{v_y}{v_x})=arctan(\frac{y+\frac{1}{2}gt^2}{x})$$
yaw **或** roll可以直接通过坐标来进行计算
当远距离吊射时，需要考虑空气阻力
此时我们进行分段调参，当距离大于阈值时，将x与y乘上系数后再进行计算
同时注意到大弹与小弹的空气阻力系数不同
所以需要使用不同的参数进行调参

## 数据接口
调用函数时传入Eigen::Matrix<double,3,1> p表示目标在base系下的坐标
传出结构体bullet_res，包含yaw或roll ，pitch ，与子弹飞行时间t


# jsoncpp
由于后期会大量进行调参，为了避免重新编译，我们将参数写入json文件中，在程序开始运行读取参数
## 学习资料
https://www.cnblogs.com/kex1n/archive/2011/12/02/2272328.html
不知道为什么.asDouble用不了，可以用std::stod(xxx.asString())代替
